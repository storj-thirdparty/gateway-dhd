package cmd

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/spf13/cobra"
	"github.com/swaggo/files" // swagger embed files
	"github.com/swaggo/gin-swagger" // gin-swagger middleware
	"github.com/storj-thirdparty/gateway-dhd/docs" // docs is generated by Swag CLI
	"storj.io/uplink"
)

// port represents the port no. of REST server to be setup
var startCmd = &cobra.Command{
	Use:   "start",
	Short: "start the REST server",
	Long:  `start the REST server`,
	Run:   startServer,
}

func init() {

	// Setup the start command with its flags.
	rootCmd.AddCommand(startCmd)
	var defaultPortNo string
	startCmd.Flags().StringVarP(&defaultPortNo, "port", "p", "8080", "Port number of the REST server")
	startCmd.Flags().BoolP("enableDocs", "e", false, "For generating UI documentation of the REST server")

}

// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @query.collection.format multi

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization

// @x-extension-openapi {"example": "value on a json format"}
func startServer(cmd *cobra.Command, args []string) {

	port, _ := cmd.Flags().GetString("port")
	enableDocs, _ := cmd.Flags().GetBool("enableDocs")

	// programmatically set swagger info
	docs.SwaggerInfo.Title = "Storj Gateway-DHD API"
	docs.SwaggerInfo.Description = "This is a REST server to stream Storj objects from libuplink to the client & vice versa."
	docs.SwaggerInfo.Version = "1.0"
	docs.SwaggerInfo.Schemes = []string{"http", "https"}

	// Set gin to Release Mode before initializing the gin router
	gin.SetMode(gin.ReleaseMode)

	// Initialize the gin router
	router := gin.Default()

	// GET request
	router.GET("/transfer/:bucketName/*objectPath", DownloadObject)

	// POST request
	router.POST("/transfer/:bucketName/*objectPathPrefix", UploadObject)

	// use ginSwagger middleware to serve the API docs if enabled by the CLI flags
	if enableDocs {
		router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	}

	// Listen and serve
	router.Run(":" + port)

}

// DownloadObject godoc
// @Summary Download a Storj object
// @Description Download a Storj object by its bucketName & objectPath
// @Produce application/json
// @Produce text/plain
// @Produce application/octet-stream
// @Produce video/mp4
// @Produce image/png
// @Produce image/jpeg
// @Produce image/gif
// @Param bucketName path string true "Bucket Name"
// @Param objectPath path string true "Object Path"
// @Header 200 {string} Token "qwerty"
// @Router /transfer/{bucketName}/{objectPath} [get]
// @Security ApiKeyAuth
// @Tags Object Operations
func DownloadObject(c *gin.Context) {

	// Create a custom header
	c.Header("x-storj-metadata", "")

	// Get bucket name and object path from GET request
	bucketName := c.Param("bucketName")
	objectPathWithSlash := c.Param("objectPath")
	objectPath := objectPathWithSlash[1:]

	// Get serialized access key from the Authorization Header entered
	reqToken := c.GetHeader("Authorization")
	if reqToken == "" {
		c.Status(http.StatusBadRequest)
		log.Print("Entered Authorization Header is in improper format")
		return
	}

	index := strings.Index(reqToken, "Storj ")
	size := len("Storj ")

	if index == -1 {
		c.Status(http.StatusBadRequest)
		log.Print("Entered Authorization Header is in improper format")
		return
	}

	serializedKey := reqToken[index+size:]

	access, err := uplink.ParseAccess(serializedKey)
	if err != nil {
		c.Status(http.StatusUnauthorized)
		log.Print(err)
		return
	}
	// Access handle obtained from Storj uplink

	project, err := uplink.OpenProject(context.Background(), access)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}
	// Project handle obtained from Storj uplink
	defer project.Close()

	obj, err := project.StatObject(context.Background(), bucketName, objectPath)
	if err != nil {
		c.Status(http.StatusNotFound)
		log.Print(err)
		return
	}
	// Stat information of the object obtained from Storj uplink

	metadataObject, err := json.Marshal(obj.System)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}
	c.Writer.Header().Add("x-storj-metadata", string(metadataObject))

	// Downloading the object
	download, err := project.DownloadObject(context.Background(), bucketName, objectPath, nil)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}

	_, err = io.Copy(c.Writer, download)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}

	err = download.Close()
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}
	
	c.Writer.Header().Add("Content-Disposition", fmt.Sprintf("attachment; filename=%", objectPath))
	c.Writer.Header().Add("Content-Type", c.GetHeader("Content-Type"))
	// Object download completed & closed successfully

}

// UploadObject godoc
// @Summary Upload an object to Storj
// @Description Upload an object at the specified bucketName & objectPathPrefix on Storj
// @Accept multipart/form-data
// @Param bucketName path string true "Bucket Name"
// @Param objectPathPrefix path string true "Object Path Prefix" default(/)
// @Param file formData file true "File Name"
// @Param name formData string false "Your name" default(anonymous)
// @Param email formData string false "Your email" default(anonymous)
// @Header 200 {string} Token "qwerty"
// @Router /transfer/{bucketName}/{objectPathPrefix} [post]
// @Security ApiKeyAuth
// @Tags Object Operations
func UploadObject(c *gin.Context) {

	// Get bucket name, object path prefix and file name from the POST request so as to obtain the destination object path
	
	bucketName := c.Param("bucketName")

	objectPathPrefixWithSlash := c.Param("objectPathPrefix")
	var objectPathPrefix string
	slashIndex := strings.Index(objectPathPrefixWithSlash, "/")
	if slashIndex == 0 {
		if len(objectPathPrefixWithSlash) > 1 {
			objectPathPrefix = objectPathPrefixWithSlash[1:]
		} else {
			objectPathPrefix = ""
		}
	}
	objectPathPrefix = strings.TrimPrefix(objectPathPrefix,"/")
	objectPathPrefix = strings.TrimSuffix(objectPathPrefix,"/")

	file, err := c.FormFile("file")
	if err != nil {
		c.Status(http.StatusBadRequest)
		log.Print(err)
		return
	}
	objectName := file.Filename

	var objectPath string
	if objectPathPrefix == "" {
		objectPath = objectName
	} else {
		objectPath = objectPathPrefix + "/" + objectName
	}

	// Get object custom metadata to be set from the POST request
	uploaderName := c.PostForm("name")
	uploaderEmail := c.PostForm("email")

	// Create an uplink CustomMetaData object.
	// This would be used to set the custom metadata for the uploaded object
	metaData := uplink.CustomMetadata{
		"name": uploaderName, 
		"email": uploaderEmail,
		"uploaded through": "gateway-dhd",
	}

	// Get serialized access key from the Authorization Header entered
	reqToken := c.GetHeader("Authorization")
	if reqToken == "" {
		c.Status(http.StatusBadRequest)
		log.Print("Entered Authorization Header is in improper format")
		return
	}

	index := strings.Index(reqToken, "Storj ")
	size := len("Storj ")

	if index == -1 {
		c.Status(http.StatusBadRequest)
		log.Print("Entered Authorization Header is in improper format")
		return
	}

	serializedKey := reqToken[index+size:]

	access, err := uplink.ParseAccess(serializedKey)
	if err != nil {
		c.Status(http.StatusUnauthorized)
		log.Print(err)
		return
	}
	// Access handle obtained from Storj uplink

	project, err := uplink.OpenProject(context.Background(), access)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}
	// Project handle obtained from Storj uplink
	defer project.Close()

	// Get the io.Reader from the file to be uploaded
	objectReader, err := file.Open()
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}

	// Intitiate the upload of our Object to the specified bucket and object path prefix
	upload, err := project.UploadObject(context.Background(), bucketName, objectPath, nil)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}

	// Copy the data to the upload.
	_, err = io.Copy(upload, objectReader)
	if err != nil {
		abortErr := upload.Abort()
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		log.Print(abortErr)
		return
	}

	// Set the custom metadata to be included with the object.
	err = upload.SetCustomMetadata(context.Background(), metaData)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}

	// Commit the uploaded object.
	err = upload.Commit()
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}

	// Stat the uploaded object information to display its custom metadata in the response header
	obj, err := project.StatObject(context.Background(), bucketName, objectPath)
	if err != nil {
		c.Status(http.StatusNotFound)
		log.Print(err)
		return
	}
	// Stat information of the object obtained from Storj uplink

	metadataObject, err := json.Marshal(obj.Custom)
	if err != nil {
		c.Status(http.StatusInternalServerError)
		log.Print(err)
		return
	}
	
	// Show the custom metadata of the uploaded object in the response header 
	c.Writer.Header().Add("x-storj-custom-metadata", string(metadataObject))

	// Object uploaded, its custom metadata set and then upload committed successfully
	c.Status(http.StatusCreated)

}